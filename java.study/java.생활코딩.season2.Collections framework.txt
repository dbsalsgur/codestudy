1. ArrayList의 사용법
- 배열은 선언할 때, 그 크기를 지정해야 하고, 만약 그 범위를 벗어나면 오류가 발생한다. 이러한 단점을 보완하기 위한 것이 바로 ArrayList이다.
- ArrayList는 java.util.ArrayList;로 java.util에 포함된 패키지를 import해야 한다.
- ArrayList의 선언 방법은 아래와 같다.
ex) ArrayList al = new ArrayList();
- ArrayList에 리터럴을 담는 방법은 아래와 같다.
ex) al.add("one");
    al.add("two");
- add() 메소드는 어떠한 형태의 데이터 타입도 수용 가능하다.
  →매개변수로 무조건 Object가 와야한다.
- ArrayList의 길이를 구하려면 .length가 아닌 .size()라는 메소드를 사용해야 한다.
ex) for(int i=0; i<al.size(); i++)
- ArrayList에 저장된 값을 반환하려면 .get(i)를 사용해야 한다.
ex) System.out.println(al.get(i));
- ArrayList에 저장된 값은 기본적으로 Object 데이터 타입으로 저장되어 있다.
 →String과 같은 타입으로 호출하거나 변수에 담고 싶다면, 형변환을 해주어야 한다.
- 위와 같이 변수 하나하나에 값을 담을 때마다 형변환을 하는 것은 비효율적이다. 이로 인해 제네릭을 ArrayList에 적용할 수 있게 되었다.
ex) ArrayList<String> al = new ArrayList<String>();\

2. 전체적인 구성
- Collections framework : Collection과 map으로 나뉘며, Collection아래에는 set, List, Queue가 있다.
- set, List, Queue에도 하위 항목이 있다.
- Collections framework는 컨테이너라고도 한다.
- List : 자신이 배열과 비슷한 것이 필요한데, 저장공간이 자동으로 늘어나는 것이 필요하면 사용하는 컨테이너
- set : 관리해야 하는 데이터가 중복적으로 저장되지 않는 컨테이너가 필요할 때 사용하는 컨테이너
- List는 데이터가 동일하든 말든 넣는대로 저장되는 반면, set은 저장 시 기존에 저장한 데이터인지를 확인하여 있던 것이면 저장하지 않고, 새로운 데이터만을 저장해나간다.

3. Set이란?
- 수학의 집합과 같다.
 → 집합의 원소는 같은 값을 2개 이상 담는 것을 허용하지 않는다. 고유한 값 한가지씩만 담을 수 있다.
- containsAll() : 한 HashSet에 있는 데이터가 다른 HashSet에 모두 포함되어 있는지를 확인하는 메소드
ex) A.containsAll(B) →A라는 HashSet에 B라는 HashSet의 구성요소가 모두 들어 있는가
 → 결과는 boolean타입으로 반환된다.
 → 부분집합과 같은 개념
- addAll() : 한 HashSet에 다른 HashSet의 값을 모두 넣는다.
ex) A.addAll(B) → A라는 HashSet에 B의 구성요소를 모두 넣는다.
 → 중복되지 않는 고유의 값이 모두 들어간다.
 → 합집합과 같은 개념
- retainAll() : 한 HashSet에 있는 요소와 다른 HashSet에 있는 요소 중 겹치는 요소를 한 HashSet에 저장
ex) A.retainAll(B) : A에 있는 요소와 B에 있는 요소 중 겹치는 요소만 A에 저장(기존에 있는 것은 없어짐)
 → 교집합과 같은 개념
- removeAll() : 한 HashSet에 있는 요소와 다른 HashSet에 있는 요소 중 겹치는 요소만 한 HashSet의 요소에서 제외시킴
ex) A.removeAll(B) : A에 있는 요소와 B에 있는 요소 중 겹치는 요소를 A에서 제외시킴
 → 차집합과 같은 개념
- List는 저장한 순서대로 저장되나, Set은 순서가 보장되지 않는다. 